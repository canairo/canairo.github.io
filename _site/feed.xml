<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-10-18T07:26:51+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">wrenches</title><subtitle>ever since i was young i always dreamed of owning my own self</subtitle><entry><title type="html">project postmortem</title><link href="http://localhost:4000/2025/10/18/project-postmortem.html" rel="alternate" type="text/html" title="project postmortem" /><published>2025-10-18T05:40:00+08:00</published><updated>2025-10-18T05:40:00+08:00</updated><id>http://localhost:4000/2025/10/18/project-postmortem</id><content type="html" xml:base="http://localhost:4000/2025/10/18/project-postmortem.html"><![CDATA[<p>i had to do a uni python proj that involved writing a ‘phishing email detector’. it was fun and i liked doing it. here is some overly technical, recherche nonsense about the implementation details of things that i want to talk about.</p>

<h3 id="project-specifications">project specifications</h3>

<p>essentially it just had to be a web app that would take in an email and determine whether or not it was phishing based on some pre-defined criteria. there is not a lot of space for creativity within these criteria (altho i think my teammates did a vv good job of coming up with cool interesting stuff to implement that wasn’t specified in the proj requirements) and so a lot of the interesting stuff i encountered was actually in the nitty gritty implementation details of stuff, like:</p>

<h3 id="big-data">big data</h3>

<p>so the way our model worked is we would have certain criteria (functions) that wld accept a <code class="language-plaintext highlighter-rouge">ProcessedEmail</code> class and return an integer. using a labeled dataset of emails (w/ label corresponding to phishing | non-phishing), collect the <code class="language-plaintext highlighter-rouge">int</code> avgs of how each category of email ‘performs’ against the different criteria, which provides a good benchmark w/ which to compare.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProcessedEmail</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                       <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                       <span class="n">subject</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                       <span class="n">attachments</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> 
                       <span class="n">is_phishing</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                       <span class="n">auxiliary_scans_enabled</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sender</span> <span class="o">=</span> <span class="n">sender</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">subject</span> <span class="o">=</span> <span class="n">subject</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">attachments</span> <span class="o">=</span> <span class="n">attachments</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">is_phishing</span> <span class="o">=</span> <span class="n">is_phishing</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">auxiliary_scans_enabled</span> <span class="o">=</span> <span class="n">auxiliary_scans_enabled</span>
</code></pre></div></div>

<p>e.g. say for a certain criteria <code class="language-plaintext highlighter-rouge">domain-check</code> most non-phishing emails score -0.5 around there, and most phishing emails score 0.5. if i test an email and it scores 0.9, it’s likely to be phishing, for obvious reasons. we just take our score and see which average it’s nearer to.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[i had to do a uni python proj that involved writing a ‘phishing email detector’. it was fun and i liked doing it. here is some overly technical, recherche nonsense about the implementation details of things that i want to talk about.]]></summary></entry></feed>